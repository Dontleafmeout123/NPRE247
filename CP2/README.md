# NPRE247

Computational Project 2 focuses on the process of calculating eigenvalues and eigenvectors for a material based on different absorption and scattering crosssections. 

This input is given in the csvs referenced in the project, both files have absorption data and scattering data for different materials. The materials are listed in the first line. The first group of data is the absorption and fission data for the different groups as well as all of the Chi vlaues for the different groups. This data is then followed by all of the scattering data. To read this table, the column is the energy group the neutron is coming from and the row is the energy group the neutron is going to. 

The first part of the code works on reading this data. It also, in the process, creates the matrices it can - the absorption and fission matrices. The absorption matrices are based on teh first column of data from the first group of data, and are just placed on the main diagonal of a square matrix. The fission matrices are filled based off the second column of data from the first group of data - the number of neutrons produced from fission for a certain energy group, and a chi value. This square matrix is filled by products of fission which increases based on the column number, and chi which increases based on the row number. Then the in scattering and out scattering matrices are created. The inscattering matrix is the same as the scattering matrix - just the data from the table - except the main diagonal is replaced with zeros. The outscattering matrix is a new matrix where each column is summed, except for the matching row number, and the sum is placed on the main diagonal spot of the column. This results in another scalar matrix. Now that all of the data is processed the math is done

First the migration matrix is created based on the absorption, outscattering and in scattering matrix. Then this is combined with the fission matrix to get B. Once we have B we can use the computer package to generate all of the (real) eigenenvalues and corresponding eigenvectors. Then we calculate the largest eigenvalue and its corresponding eigenvector through poweriteration. This is done in the power iterate function for a set number of cycles (2 cycles). 

The results from both the computer method and the power iteration method as well as the original data, once properly parsed and organized, is all dumped into an outgenerated json file, based on the name of the input file name.


(The ipynb_checkpoints are autogenerated)

